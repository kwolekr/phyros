/*-
 * Copyright (c) 2008 Ryan Kwolek
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this list of
 *     conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice, this list
 *     of conditions and the following disclaimer in the documentation and/or other materials
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* 
 * cdkey.c - 
 *    Product CD-Key decoding, hashing, and support routines
 */

#include "../main.h"
#include "../fxns.h"
#include "cdkey.h"

const unsigned char WC3KeyMap[] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x00, 0xFF, 0x01, 0xFF, 0x02, 0x03,  0x04, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

	0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,  0x0C, 0xFF, 0x0D, 0x0E, 0xFF, 0x0F, 0x10, 0xFF,
	0x11, 0xFF, 0x12, 0xFF, 0x13, 0xFF, 0x14, 0x15,  0x16, 0x17, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,  0x0C, 0xFF, 0x0D, 0x0E, 0xFF, 0x0F, 0x10, 0xFF,
	0x11, 0xFF, 0x12, 0xFF, 0x13, 0xFF, 0x14, 0x15,  0x16, 0x17, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
};

const unsigned char WC3TranslateTable[] = {
    0x09, 0x04, 0x07, 0x0F, 0x0D, 0x0A, 0x03, 0x0B, 0x01, 0x02, 0x0C, 0x08,
    0x06, 0x0E, 0x05, 0x00, 0x09, 0x0B, 0x05, 0x04, 0x08, 0x0F, 0x01, 0x0E,
    0x07, 0x00, 0x03, 0x02, 0x0A, 0x06, 0x0D, 0x0C, 0x0C, 0x0E, 0x01, 0x04,
    0x09, 0x0F, 0x0A, 0x0B, 0x0D, 0x06, 0x00, 0x08, 0x07, 0x02, 0x05, 0x03,
    0x0B, 0x02, 0x05, 0x0E, 0x0D, 0x03, 0x09, 0x00, 0x01, 0x0F, 0x07, 0x0C,
    0x0A, 0x06, 0x04, 0x08, 0x06, 0x02, 0x04, 0x05, 0x0B, 0x08, 0x0C, 0x0E,

    0x0D, 0x0F, 0x07, 0x01, 0x0A, 0x00, 0x03, 0x09, 0x05, 0x04, 0x0E, 0x0C,
    0x07, 0x06, 0x0D, 0x0A, 0x0F, 0x02, 0x09, 0x01, 0x00, 0x0B, 0x08, 0x03,
    0x0C, 0x07, 0x08, 0x0F, 0x0B, 0x00, 0x05, 0x09, 0x0D, 0x0A, 0x06, 0x0E,
    0x02, 0x04, 0x03, 0x01, 0x03, 0x0A, 0x0E, 0x08, 0x01, 0x0B, 0x05, 0x04,
    0x02, 0x0F, 0x0D, 0x0C, 0x06, 0x07, 0x09, 0x00, 0x0C, 0x0D, 0x01, 0x0F,

    0x08, 0x0E, 0x05, 0x0B, 0x03, 0x0A, 0x09, 0x00, 0x07, 0x02, 0x04, 0x06,
    0x0D, 0x0A, 0x07, 0x0E, 0x01, 0x06, 0x0B, 0x08, 0x0F, 0x0C, 0x05, 0x02,
    0x03, 0x00, 0x04, 0x09, 0x03, 0x0E, 0x07, 0x05, 0x0B, 0x0F, 0x08, 0x0C,
    0x01, 0x0A, 0x04, 0x0D, 0x00, 0x06, 0x09, 0x02, 0x0B, 0x06, 0x09, 0x04,
    0x01, 0x08, 0x0A, 0x0D, 0x07, 0x0E, 0x00, 0x0C, 0x0F, 0x02, 0x03, 0x05,

    0x0C, 0x07, 0x08, 0x0D, 0x03, 0x0B, 0x00, 0x0E, 0x06, 0x0F, 0x09, 0x04,
    0x0A, 0x01, 0x05, 0x02, 0x0C, 0x06, 0x0D, 0x09, 0x0B, 0x00, 0x01, 0x02,
    0x0F, 0x07, 0x03, 0x04, 0x0A, 0x0E, 0x08, 0x05, 0x03, 0x06, 0x01, 0x05,
    0x0B, 0x0C, 0x08, 0x00, 0x0F, 0x0E, 0x09, 0x04, 0x07, 0x0A, 0x0D, 0x02,
    0x0A, 0x07, 0x0B, 0x0F, 0x02, 0x08, 0x00, 0x0D, 0x0E, 0x0C, 0x01, 0x06,

    0x09, 0x03, 0x05, 0x04, 0x0A, 0x0B, 0x0D, 0x04, 0x03, 0x08, 0x05, 0x09,
    0x01, 0x00, 0x0F, 0x0C, 0x07, 0x0E, 0x02, 0x06, 0x0B, 0x04, 0x0D, 0x0F,
    0x01, 0x06, 0x03, 0x0E, 0x07, 0x0A, 0x0C, 0x08, 0x09, 0x02, 0x05, 0x00,
    0x09, 0x06, 0x07, 0x00, 0x01, 0x0A, 0x0D, 0x02, 0x03, 0x0E, 0x0F, 0x0C,
    0x05, 0x0B, 0x04, 0x08, 0x0D, 0x0E, 0x05, 0x06, 0x01, 0x09, 0x08, 0x0C,

    0x02, 0x0F, 0x03, 0x07, 0x0B, 0x04, 0x00, 0x0A, 0x09, 0x0F, 0x04, 0x00,
    0x01, 0x06, 0x0A, 0x0E, 0x02, 0x03, 0x07, 0x0D, 0x05, 0x0B, 0x08, 0x0C,
    0x03, 0x0E, 0x01, 0x0A, 0x02, 0x0C, 0x08, 0x04, 0x0B, 0x07, 0x0D, 0x00,
    0x0F, 0x06, 0x09, 0x05, 0x07, 0x02, 0x0C, 0x06, 0x0A, 0x08, 0x0B, 0x00,
    0x0F, 0x04, 0x03, 0x0E, 0x09, 0x01, 0x0D, 0x05, 0x0C, 0x04, 0x05, 0x09,

    0x0A, 0x02, 0x08, 0x0D, 0x03, 0x0F, 0x01, 0x0E, 0x06, 0x07, 0x0B, 0x00,
    0x0A, 0x08, 0x0E, 0x0D, 0x09, 0x0F, 0x03, 0x00, 0x04, 0x06, 0x01, 0x0C,
    0x07, 0x0B, 0x02, 0x05, 0x03, 0x0C, 0x04, 0x0A, 0x02, 0x0F, 0x0D, 0x0E,
    0x07, 0x00, 0x05, 0x08, 0x01, 0x06, 0x0B, 0x09, 0x0A, 0x0C, 0x01, 0x00,
    0x09, 0x0E, 0x0D, 0x0B, 0x03, 0x07, 0x0F, 0x08, 0x05, 0x02, 0x04, 0x06, 

    0x0E, 0x0A, 0x01, 0x08, 0x07, 0x06, 0x05, 0x0C, 0x02, 0x0F, 0x00, 0x0D,
    0x03, 0x0B, 0x04, 0x09, 0x03, 0x08, 0x0E, 0x00, 0x07, 0x09, 0x0F, 0x0C,
    0x01, 0x06, 0x0D, 0x02, 0x05, 0x0A, 0x0B, 0x04, 0x03, 0x0A, 0x0C, 0x04,
    0x0D, 0x0B, 0x09, 0x0E, 0x0F, 0x06, 0x01, 0x07, 0x02, 0x00, 0x05, 0x08
};


///////////////////////////////////////////////////////////////////////////////


void HashWAR3Key(uint32_t ClientToken, uint32_t ServerToken, 
				 unsigned int ProductVal, unsigned int PublicVal,
				 char *PrivateVal, char *output) { 
	char buffer[26];

	*(uint32_t *)buffer = ClientToken;
	*(uint32_t *)(buffer + 0x04) = ServerToken;
	*(uint32_t *)(buffer + 0x08) = ProductVal;
	*(uint32_t *)(buffer + 0x0C) = PublicVal;
	memcpy(buffer + 0x10, PrivateVal, 10); 
	SHA1(buffer, 26, output);
}


int CheckWC3Key(const char *cdkey) {
	//valid = "246789BCDEFGHJKMNPRTVWXYZbcdefghjkmnprtvwxyz";
	int i = 0;

	while (cdkey[i]) {
		if (WC3KeyMap[(unsigned char)cdkey[i++]] == 0xFF)
			return 0;
	}
	return (i == WC3_KEYLEN) ? 1 : 0;
}


void mult(int r, const int x, int *a, int dcByte) {
    while (r--) {
        int64_t edxeax = ((int64_t) (*a & 0x00000000FFFFFFFFl))
            * ((int64_t) (x & 0x00000000FFFFFFFFl));
        *a-- = dcByte + (int32_t) edxeax;
        dcByte = (int32_t) (edxeax >> 32);
    }
}


void DecodeWC3Key(char *cdkey, unsigned int *product, unsigned int *pubval, char *privval) {
    char table[WC3_BUFLEN], decode;
    int values[4];
    int a, b, i;

	b = 33;
    memset(table, 0, WC3_BUFLEN);
    memset(values, 0, (sizeof(int) * 4));

    for (i = 0; ((unsigned int) i) < WC3_KEYLEN; i++) {
        a = (b + 1973) % WC3_BUFLEN;
        b = (a + 1973) % WC3_BUFLEN;
        decode = WC3KeyMap[(unsigned char)cdkey[i]];
        table[a] = (decode / 5);
        table[b] = (decode % 5);
    }

    i = WC3_BUFLEN;
	while (i--)
        mult(4, 5, values + 3, table[i]);

    DecodeKeyTable(values);
	*product = values[0] >> 10;

	for (i = 0; i < 4; i++)
		values[i] = SWAP4(values[i]);

	*pubval = SWAP4((*(uint32_t *)(((char *)values) + 2)) & 0xFFFFFF00);
	*((uint16_t *)(privval))	 = SWAP2(*(uint16_t *)(((char *)values) + 6));
	*((uint32_t *)(privval + 2)) = SWAP4(*(uint32_t *)(((char *)values) + 8));
	*((uint32_t *)(privval + 6)) = SWAP4(*(uint32_t *)(((char *)values) + 12));
}


void DecodeKeyTable(int *keyTable) {
    unsigned int eax, ecx, edx, edi, esi, ebp;
    unsigned int varC, var4, var8, location;
    unsigned int copy[4];
    unsigned char *scopy;
    int i;

    var8 = 29;
    i = 464;

    do {
        int j;
        esi = (var8 & 7) << 2;
        var4 = var8 >> 3;
        varC = (unsigned int)(keyTable[3 - var4] & (0xF << esi)) >> esi;

        if (i < 464) {
            for (j = 29; (unsigned int) j > var8; j--) {
                ecx = (j & 7) << 2;
                ebp = ((unsigned int)((keyTable[0x3 - (j >> 3)]) & (0xF << ecx)) >> ecx);
                varC = WC3TranslateTable[ebp ^ (WC3TranslateTable[varC + i] + i)];
            }
        }

        j = --var8;
        while (j >= 0) {
            ecx = (j & 7) << 2;
            ebp = (unsigned int)((keyTable[0x3 - (j >> 3)]) & (0xF << ecx)) >> ecx;
            varC = WC3TranslateTable[ebp ^ (WC3TranslateTable[varC + i] + i)];
            j--;
        }

        j = 3 - var4;
        keyTable[j] = (((WC3TranslateTable[varC + i] & 0xF) << esi) | (~(0xF << esi) & ((int) keyTable[j])));
    } while ((i -= 16) >= 0);

    eax = 0;
    edx = 0;
    ecx = 0;
    edi = 0;
    esi = 0;
    ebp = 0;

    for (i = 0; i < 4; i++)
        copy[i] = keyTable[i];

    scopy = (unsigned char *)copy;
    for (edi = 0; edi < 120; edi++) {
        location = 12;
        eax = edi & 0x1F;
        ecx = esi & 0x1F;

        edx = 3 - (edi >> 5);
        location -= ((esi >> 5) << 2);

        ebp = (*(int32_t *)(scopy + location) & (1 << ecx)) >> ecx;
        keyTable[edx] = ((ebp & 1) << eax) | (~(1 << eax) & keyTable[edx]);

        esi += 11;
        if (esi >= 120)
            esi -= 120;
    }
}

